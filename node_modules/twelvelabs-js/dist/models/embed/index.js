"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddingsTask = exports.EmbeddingsTaskStatus = exports.CreateEmbeddingsResult = void 0;
class CreateEmbeddingsResult {
    constructor(data) {
        this.engineName = data.engineName;
        this.textEmbedding = data.textEmbedding;
    }
}
exports.CreateEmbeddingsResult = CreateEmbeddingsResult;
class EmbeddingsTaskStatus {
    constructor(data) {
        this.id = data.id;
        this.engineName = data.engineName;
        this.status = data.status;
    }
}
exports.EmbeddingsTaskStatus = EmbeddingsTaskStatus;
class EmbeddingsTask {
    constructor(resource, data) {
        this._resource = resource;
        this.id = data.id;
        this.engineName = data.engineName;
        this.status = data.status;
        this.videoEmbeddings = data.videoEmbeddings;
    }
    async retrieve(options = {}) {
        return await this._resource.retrieve(this.id, options);
    }
    async getStatus(options = {}) {
        const { status } = await this._resource.status(this.id, options);
        return status;
    }
    async waitForDone(sleepInterval = 5000, callback) {
        const isDone = () => this.status === 'ready' || this.status === 'failed';
        if (sleepInterval <= 0) {
            throw new Error('sleepInterval must be greater than 0');
        }
        while (!isDone()) {
            await this.sleep(sleepInterval);
            try {
                this.status = await this.getStatus();
            }
            catch (err) {
                console.warn(`Retrieving status failed: ${err.message}, retrying..`);
                continue;
            }
            if (callback) {
                callback(this);
            }
        }
        return this.status;
    }
    sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
}
exports.EmbeddingsTask = EmbeddingsTask;
//# sourceMappingURL=index.js.map